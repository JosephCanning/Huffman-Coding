/*
 *  Name: Joseph Canning
 *  Class: CSCI-340
 *  Assignment: Project 2 - HuffmanCodes
 *  Professor: Stuart Hansen
 *  Date Due: 2/28/2018
 *
 *  Program Purpose:    This program implements the Huffman coding compression algorithm for text files. Huffman codes
 *                      are variable in length (in contrast to standards like ASCII where each letter is one byte).
 *                      The file to be compressed is processed to find all characters in use; those characters are then
 *                      sorted by their frequency of use within the file. New codes are assigned to each unique
 *                      character. The most frequently used characters are given the shortest codes, and the least
 *                      frequently used codes are assigned the longest ones. Finally, the codes are written to their
 *                      their own file, and the encoded text is written to another file. The program also includes a
 *                      decode method that utilizes the code file to decompress a file that was compressed using
 *                      Huffman.
 */

import java.io.File;
import java.io.PrintWriter;
import java.io.RandomAccessFile;
import java.util.*;

public class Huffman {

    /*
     *  encode():   encode() takes three String arguments: originalFileName, codeFileName, and compressedFileName. All
     *              of the parameters are self-describing. encode() is the primary method in Huffman and calls most of
     *              the other methods in the class. First, various IO objects are instantiated to read/write from/to
     *              the files. A TreeMap, data, is also instantiated to hold the unique characters in the original file
     *              as keys and a HuffmanMapValue (see below) as the value. A Node PriorityQueue, q, is created along
     *              with a Tree, tree. q uses Nodes' frequencies in its comparator. Next, data is filled. q is
     *              then provided with a Node corresponding to each entry in data. The Huffman tree is built and stored
     *              in tree. Next, the character codes are all generated by navigating the tree to its leaves. Lastly,
     *              both output files are written. Various exceptions are thrown within this method and are deferred.
     */
    public static void encode(String originalFileName, String codeFileName, String compressedFileName) throws Exception {

        PrintWriter codeFile = new PrintWriter(codeFileName);
        RandomAccessFile in = new RandomAccessFile(new File(originalFileName), "r");
        BitOutputStream out = new BitOutputStream(compressedFileName);
        TreeMap<Character, HuffmanMapValue> data = new TreeMap<>();
        PriorityQueue<Node> q = new PriorityQueue<>(Comparator.comparingInt(Node::getFreq));
        Tree tree;

        int nextChar = 0;

        while (nextChar != -1) {

            nextChar = in.read();

            if (data.containsKey((char)nextChar)) {
                data.get((char)nextChar).increase();
            } else {
                data.put((char)nextChar, new HuffmanMapValue(1, ""));
            }

        }

        for (Map.Entry<Character, HuffmanMapValue> entry : data.entrySet()) {
            q.add(new Node(entry.getKey(), entry.getValue().getOccurrences()));
        }

        tree = buildTree(q);
        generateCodes(tree.getRoot(), data, "");
        writeCodes(codeFile, data);
        compress(in, out, data);

    }

    /*
     *  compress(): Three arguments are accepted: a RandomAccessFile, in, a BitOutputStream, out, and a TreeMap, map.
     *              This method is quite simple, as it just reads a character from in, searches map, and writes that
     *              character's Huffman code with out to the compressed file. An IOException is thrown.
     */
    private static void compress(RandomAccessFile in, BitOutputStream out, TreeMap<Character, HuffmanMapValue> map) throws java.io.IOException {

        int nextChar = 0;
        in.seek(0L);

        while (nextChar != -1) {

            nextChar = in.read();
            out.writeString(map.get((char)nextChar).getCode());

        }

        in.close();
        out.close();

    }

    /*
     *  writeCodes():   Takes arguments out and map. A for loop goes to each entry in map and uses out to write that
     *                  entry's character ASCII code, frequency, and code. A single line is dedicated to each character
     *                  in the codes file.
     */
    private static void writeCodes(PrintWriter out, TreeMap<Character, HuffmanMapValue> map) {

        for (Map.Entry<Character, HuffmanMapValue> entry : map.entrySet()) {
            out.println((int)entry.getKey() + "\t" + entry.getValue().getOccurrences() + "\t" + entry.getValue().getCode());
        }

        out.close();

    }

    /*
     *  buildTree():    Given a PriorityQueue of Nodes called q, this method follows the algorithm for constructing a
     *                  Huffman tree. The two lowest priority Nodes in q are made the children of a new Node; the new
     *                  Node's frequency is made to be the sum of the frequencies of its children then the Node is
     *                  added to the PriorityQueue. This process stops when only one Node remains in q. This last Node
     *                  is the root of the completed Huffman tree.
     */
    private static Tree buildTree(PriorityQueue<Node> q) {

        while (q.size() > 1) {

            Node left = q.poll();
            Node right = q.poll();
            Node node = new Node(left.getFreq() + right.getFreq());
            node.setLeft(left);
            node.setRight(right);
            q.add(node);

        }

        return new Tree(q.poll());

    }

    /*
     *  generateCodes():    Given a Node, root, a TreeMap map, and an empty String, code, this method will traverse
     *                      recursively through a Huffman tree to its leaves and concatenate a 0 to code if it goes
     *                      left and 1 if it goes right. Upon reaching a leaf Node, that Node's character's entry is
     *                      updated in map to have its code equal to the String code.
     */
    private static void generateCodes(Node root, TreeMap<Character, HuffmanMapValue> map, String code) {

        if (root.getLeft() == null && root.getRight() == null && root.getSymbol() != null) {

            map.get(root.getSymbol()).setCode(code);

        } else {

            generateCodes(root.getLeft(), map, code + "0");
            generateCodes(root.getRight(), map, code + "1");

        }

    }

    /*
     *  decode():   See encode() for explanation of these nearly identical arguments. decode() decompresses
     *              a file that has been previously compressed by this program. The compressed file is read through
     *              completely; it is read one bit at a time, and those bits are aggregated into a StringBuilder named
     *              bits. After a new bit has been read and appended, the code file is read line by line; each line
     *              contains the int representation of one character as well as its frequency and its Huffman code.
     *              If bits matches the Huffman code, then that character is written to the decompressed file.
     *              Otherwise, new bits are appended to bits until it matches some character.
     */
    public static void decode(String compressedFileName, String codeFileName, String decompressedFileName) throws Exception {

        BitInputStream inBin = new BitInputStream(compressedFileName);
        Scanner in = new Scanner(new File(codeFileName));
        PrintWriter out = new PrintWriter(decompressedFileName);
        StringBuilder bits = new StringBuilder("");

        int nextBit = 0;
        char nextChar;
        String line;
        String[] nums;

        while (nextBit != -1) {

            nextBit = inBin.readBit();

            if (nextBit == 1) {
                bits.append("1");
            }

            if (nextBit == 0) {
                bits.append("0");
            }

            while (in.hasNextLine()) {

                line = in.nextLine();
                nums = line.split("\t");

                if (nums[2].equals(bits.toString())) {

                    nextChar = (char) Integer.parseInt(nums[0]);
                    out.print(nextChar);
                    bits = new StringBuilder();

                }

            }

            in = new Scanner(new File(codeFileName));

        }

        in.close();
        out.close();

    }

    /*
     *  HuffmanMapValue:    This class is an aggregation of int and String data to be used as the value in the TreeMap
     *                      that holds the "alphabet" of the file to be compressed. The int represents the occurrences
     *                      of a character and the String represents the Huffman code of that character. A constructor
     *                      sets both of these values, and methods are provided to manipulate them.
     */
    private static class HuffmanMapValue {

        private int occurrences;
        private String code;

        public HuffmanMapValue(int occurrences, String code) {

            this.occurrences = occurrences;
            this.code = code;

        }

        public void increase() { occurrences++; }
        public int getOccurrences() { return occurrences; }
        public String getCode() { return code; }
        public void setCode(String code) { this.code = code; }

    }

    /*
     *  Tree:   A basic class to hold a tree of Nodes.
     */
    private static class Tree {

        private Node root;

        public Tree(Node root) {
            this.root = root;
        }
        public Node getRoot() { return root; }

    }

    /*
     *  Node:   For use in a Huffman tree. Each Node object has two values: a Character, symbol, and an int, freq. Each
     *          Node also has two child-Nodes. Two constructors are provided; the first is to be used in the creation
     *          of Leaf nodes while the second is to be used in the creation of internal nodes i.e. made during tree
     *          construction. Various methods are provided to manipulate data.
     */
    private static class Node {

        private Character symbol;
        private int freq;
        private Node left;
        private Node right;

        public Node(Character value, int freq) {

            this.symbol = value;
            this.freq = freq;
            left = null;
            right = null;

        }

        public Node(int freq) {

            this.freq = freq;
            left = null;
            right = null;

        }

        public Character getSymbol() { return symbol; }
        public int getFreq() { return freq; }
        public Node getLeft() { return left; }
        public Node getRight() { return right; }
        public void setLeft(Node left) { this.left = left; }
        public void setRight(Node right) { this.right = right; }

    }

    public static void main(String[] args) {

		// Run compression here

    }

}
